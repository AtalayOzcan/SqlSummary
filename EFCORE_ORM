ORM NEDÄ°R?
ORM SQL SORGULARINI C# DÄ°LÄ°NDE YAZIP ARKA PLANDA BU KODUN SQL'E DÃ–NÃœÅMESÄ°DÄ°R.
ORM (Object-Relational Mapping), yazÄ±lÄ±m geliÅŸtirmede kullanÄ±lan bir tekniktir. AmaÃ§, nesne tabanlÄ± programlama dilleri (C#, Java, Python gibi) ile iliÅŸkisel veritabanlarÄ± (SQL Server, PostgreSQL, MySQL vb.) arasÄ±ndaki veri etkileÅŸimini kolaylaÅŸtÄ±rmaktÄ±r.
Daha basit anlatÄ±rsak:
Normalde veritabanÄ±yla konuÅŸmak iÃ§in SQL sorgularÄ± yazman gerekir.
ORM sayesinde tablo, sÃ¼tun, iliÅŸki gibi kavramlar sÄ±nÄ±flar ve nesneler olarak kodunda temsil edilir.
Sen SQL sorgusu yazmak yerine nesnelerle Ã§alÄ±ÅŸÄ±rsÄ±n, ORM arka planda bunu SQLâ€™e dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.

ORM = SQL yazmadan veritabanÄ±yla nesne tabanlÄ± ÅŸekilde konuÅŸmanÄ± saÄŸlayan yapÄ±.

EF CORE NEDÄ°R?
Entity Framework Core Microsoft'un geliÅŸtirdiÄŸi aÃ§Ä±k kaynaklÄ± bir ORM aracÄ±dÄ±r.
SEN LINQ SORGULARI YAZARSIN EF CORE SENÄ°N Ä°Ã‡Ä°N BUNU ARKA PLANDA SQL SORGULARINA Ã‡EVÄ°RÄ°R.
AYRICA MSSQL,POSTRESQL,SQLÄ°TE GÄ°BÄ° BÄ°RÃ‡OK DATABASE Ä°LE BÄ°RLÄ°KTE KULLANILABÄ°LÄ°R.

[C# Code]  
var users = db.Users
              .Where(u => u.Name == "Atalay")
              .ToList();

       â”‚  (LINQ Query)
       â–¼
[EF Core]  â†’  LINQ sorgusunu SQLâ€™e dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r
       â”‚
       â–¼
[SQL]  
SELECT * FROM Users WHERE Name = 'Atalay';

       â”‚
       â–¼
[Database]  
Users tablosundan sonuÃ§larÄ± dÃ¶ner

C# Kod â†’ EF Core â†’ SQL â†’ Database â†’ SonuÃ§ (Class Nesneleri)

PRÄ°MARY KEY AND FOREÄ°GN KEY NEDÄ°R?
-PRÄ°MARY KEY:BÄ°RÄ°NCÄ°L ANAHTAR
Bir tablodaki her satÄ±rÄ± benzersiz (unique) ÅŸekilde tanÄ±mlayan sÃ¼tundur (veya sÃ¼tunlar grubudur).
Tekrarlanamaz ve NULL olamaz.
Genelde â€œIdâ€ sÃ¼tunu Primary Key olarak kullanÄ±lÄ±r.

| Id (PK) | Name   | Email                                     |
| ------- | ------ | ----------------------------------------- |
| 1       | Ali    | [ali@mail.com](mailto:ali@mail.com)       |
| 2       | AyÅŸe   | [ayse@mail.com](mailto:ayse@mail.com)     |
| 3       | Atalay | [atalay@mail.com](mailto:atalay@mail.com) |

-FOREIGN KEY:YABANCI ANAHTAR
Bir tablodaki sÃ¼tunun, baÅŸka bir tablodaki Primary Keyâ€™e referans vermesidir.
Tablolar arasÄ±nda iliÅŸki kurmayÄ± saÄŸlar.

| OrderId (PK) | UserId (FK) | Product |
| ------------ | ----------- | ------- |
| 101          | 1           | Laptop  |
| 102          | 2           | Telefon |
| 103          | 1           | Klavye  |
UserId sÃ¼tunu Foreign Keyâ€™dir.
Bu sÃ¼tun, Users tablosundaki Id (Primary Key)â€™e referans verir.
BÃ¶ylece hangi sipariÅŸin hangi kullanÄ±cÄ±ya ait olduÄŸu bilinir.
MESELA ID=1 ADLI KULLANICI ORDERS KISMINDA USERID = 1 OLARAK HEM LAPTOP HEM KLAVYE ALMIÅ.

Primary Key â†’ Tablo iÃ§indeki benzersiz satÄ±rÄ± tanÄ±mlar.
Foreign Key â†’ BaÅŸka bir tablonun Primary Keyâ€™ine baÄŸlanÄ±r.

VeritabanÄ± Ä°liÅŸkileri
Ä°liÅŸkiler, tablolarÄ±n Primary Key (PK) ve Foreign Key (FK) Ã¼zerinden kurduÄŸu baÄŸlardÄ±r.
3 temel iliÅŸki vardÄ±r:

1. One-to-One (Bire Bir Ä°liÅŸki)
TanÄ±m: Bir tablodaki her kayÄ±t, diÄŸer tablodaki yalnÄ±zca bir kayÄ±t ile eÅŸleÅŸir.
GerÃ§ek Hayat Ã–rneÄŸi:
Bir kiÅŸinin TC Kimlik NumarasÄ± sadece tek kiÅŸiye aittir.
AynÄ± ÅŸekilde o kiÅŸinin de sadece tek kimliÄŸi vardÄ±r.

| UserId (PK) | Name   |
| ----------- | ------ |
| 1           | Atalay |
| 2           | AyÅŸe   |      Burada UserProfiles.ProfileId aynÄ± zamanda Users.UserIdâ€™ye Foreign Key olarak baÄŸlÄ±.
                              Yani her kullanÄ±cÄ±ya 1 profil, her profile 1 kullanÄ±cÄ± dÃ¼ÅŸÃ¼yor.
| ProfileId (PK, FK) | Address  | Phone    |
| ------------------ | -------- | -------- |
| 1                  | Ankara   | 555-1111 |
| 2                  | Ä°stanbul | 555-2222 |

2. One-to-Many (Bire Ã‡ok Ä°liÅŸki)
TanÄ±m: Bir tablodaki bir kayÄ±t, diÄŸer tablodaki birden fazla kayÄ±tla eÅŸleÅŸebilir.
GerÃ§ek Hayat Ã–rneÄŸi:
Bir mÃ¼ÅŸteri birÃ§ok sipariÅŸ verebilir.
Ama her sipariÅŸ sadece bir mÃ¼ÅŸteriye aittir.

| UserId (PK) | Name   |
| ----------- | ------ |
| 1           | Atalay |
| 2           | AyÅŸe   |  Orders.UserId, Users.UserIdâ€™ye baÄŸlÄ±dÄ±r.
                          Atalayâ€™Ä±n 2 sipariÅŸi var.
                          AyÅŸeâ€™nin 1 sipariÅŸi var.
                          Bu yÃ¼zden iliÅŸki 1 KullanÄ±cÄ± â€“ Ã‡ok SipariÅŸ ÅŸeklindedir.
| OrderId (PK) | UserId (FK) | Product |
| ------------ | ----------- | ------- |
| 101          | 1           | Laptop  |
| 102          | 1           | Klavye  |
| 103          | 2           | Telefon |

3. Many-to-Many (Ã‡oktan Ã‡oÄŸa Ä°liÅŸki)
TanÄ±m: Bir tablodaki bir kayÄ±t, diÄŸer tablodaki birden fazla kayÄ±tla eÅŸleÅŸebilir.
AynÄ± ÅŸekilde karÅŸÄ± tablodaki bir kayÄ±t da birden fazla ile eÅŸleÅŸebilir.
Bu iliÅŸkiyi kurmak iÃ§in ara tablo (junction table) gerekir.

GerÃ§ek Hayat Ã–rneÄŸi:
Bir Ã¶ÄŸrenci birden fazla derse kayÄ±t olabilir.
AynÄ± zamanda bir dersin de birden fazla Ã¶ÄŸrencisi olabilir.

| StudentId (PK) | Name   |
| -------------- | ------ |
| 1              | Atalay |
| 2              | AyÅŸe   |

| CourseId (PK) | CourseName |
| ------------- | ---------- |
| 10            | Matematik  |
| 20            | YazÄ±lÄ±m    |

| StudentId (FK) | CourseId (FK) |  ARA TABLO (JUNCTION TABLE)
| -------------- | ------------- |
| 1              | 10            |  Atalay hem Matematik hem YazÄ±lÄ±m dersi alÄ±yor. AyÅŸe sadece YazÄ±lÄ±m dersi alÄ±yor.
| 1              | 20            |
| 2              | 20            |

Normalization (Normalizasyon) Nedir?
Normalizasyon, veritabanÄ±ndaki verileri dÃ¼zenleme sÃ¼recidir.
AmaÃ§:
Gereksiz tekrarlarÄ± (redundancy) azaltmak
Veri tutarlÄ±lÄ±ÄŸÄ±nÄ± (consistency) artÄ±rmak
Tablolar arasÄ± iliÅŸkileri mantÄ±klÄ± kurmak
Yani bir veriyi sadece bir yerde saklamak ve tekrarÄ±nÄ± Ã¶nlemek.

Neden Normalizasyon YapÄ±lÄ±r?
VeritabanÄ±nda aynÄ± bilgiyi tekrar tekrar tutarsan:
Disk alanÄ± boÅŸa harcanÄ±r.
Veri gÃ¼ncellendiÄŸinde hatalar Ã§Ä±kar (bir yerde gÃ¼ncelleyip diÄŸer yerde unutabilirsin). KarmaÅŸa olur.
Normalizasyon ile bunlar engellenir.

Normalizasyon AÅŸamalarÄ± (Normal Forms)
1. First Normal Form (1NF)
Her sÃ¼tunda sadece tekil deÄŸer olmalÄ±. (Tekrarlayan gruplar olmayacak)
Her satÄ±r benzersiz olmalÄ± (Primary Key).

Ã–rnek (YanlÄ±ÅŸ tablo):
| StudentId | Name | Courses            |
| --------- | ---- | ------------------ |
| 1         | Ali  | Matematik, Fizik   |
| 2         | AyÅŸe | YazÄ±lÄ±m, Matematik | â¡ HatalÄ± Ã§Ã¼nkÃ¼ â€œCoursesâ€ sÃ¼tununda birden fazla deÄŸer var.

ğŸ“ DoÄŸru tablo (1NFâ€™ye uygun):
| StudentId | Name |
| --------- | ---- |
| 1         | Ali  |
| 2         | AyÅŸe |

| StudentId | Course    |
| --------- | --------- |
| 1         | Matematik |
| 1         | Fizik     |
| 2         | YazÄ±lÄ±m   |
| 2         | Matematik |

2. Second Normal Form (2NF)
Ã–nce 1NF saÄŸlanmalÄ±.
Sonra tÃ¼m alanlar tamamen Primary Keyâ€™e baÄŸlÄ± olmalÄ±.
Ã–rnek (YanlÄ±ÅŸ tablo):
| StudentId | CourseId | StudentName |
| --------- | -------- | ----------- |
| 1         | 101      | Ali         |
| 1         | 102      | Ali         | â¡ HatalÄ± Ã§Ã¼nkÃ¼ â€œStudentNameâ€ aslÄ±nda sadece StudentIdâ€™ye baÄŸlÄ±dÄ±r, CourseId ile ilgisi yoktur.

DoÄŸru Ã§Ã¶zÃ¼m:
Students (StudentId, StudentName)
Courses (CourseId, CourseName)
StudentCourses (StudentId, CourseId)

3. Third Normal Form (3NF)
Ã–nce 2NF saÄŸlanmalÄ±.
Sonra tÃ¼m sÃ¼tunlar yalnÄ±zca Primary Keyâ€™e baÄŸlÄ± olmalÄ±, baÅŸka sÃ¼tunlara deÄŸil.
Ã–rnek (YanlÄ±ÅŸ tablo):
| OrderId | CustomerId | CustomerName |
| ------- | ---------- | ------------ |
| 1001    | 1          | Ali          |
DoÄŸru Ã§Ã¶zÃ¼m:
Customers (CustomerId, CustomerName)
Orders (OrderId, CustomerId)

Ã–zet
1NF â†’ Tabloda tekrar eden gruplar olmasÄ±n. (Her hÃ¼crede tek deÄŸer)
2NF â†’ SÃ¼tunlar sadece Primary Keyâ€™in tamamÄ±na baÄŸlÄ± olsun.
3NF â†’ SÃ¼tunlar sadece Primary Keyâ€™e baÄŸlÄ± olsun, baÅŸka sÃ¼tunlara deÄŸil.

ğŸ‘‰ Normalizasyonun mantÄ±ÄŸÄ± ÅŸu:
â€œVeriyi en kÃ¼Ã§Ã¼k, en baÄŸÄ±msÄ±z ve en anlamlÄ± parÃ§alar halinde sakla.â€


Constraints (KÄ±sÄ±tlamalar) Nedir?
Constraint, veritabanÄ±ndaki tablolar Ã¼zerinde kurallar koyarak veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ (data integrity) saÄŸlamaktÄ±r.
Yani tabloya yanlÄ±ÅŸ / hatalÄ± / mantÄ±ksÄ±z verilerin girilmesini engeller.
Ã–rneÄŸin: â€œBir Ã¼rÃ¼nÃ¼n fiyatÄ± eksi olamazâ€ veya â€œBir sipariÅŸin mÃ¼ÅŸterisi olmayan bir kiÅŸi olamazâ€ gibi kurallarÄ± uygulatÄ±r.

BaÅŸlÄ±ca Constraint TÃ¼rleri
1. PRIMARY KEY
Her satÄ±rÄ± benzersiz (unique) ÅŸekilde tanÄ±mlar.
NULL deÄŸer alamaz.
Bir tabloda yalnÄ±zca bir tane Primary Key olabilir (ama bu birden fazla kolondan oluÅŸabilir = composite key).

CREATE TABLE Users (
    UserId INT PRIMARY KEY,
    Name NVARCHAR(50)
);


2. FOREIGN KEY
Bir tablodaki sÃ¼tunun, baÅŸka bir tablodaki Primary Keyâ€™e referans vermesini saÄŸlar.
Tablolar arasÄ± iliÅŸki kurmak iÃ§in kullanÄ±lÄ±r.
CREATE TABLE Orders (
    OrderId INT PRIMARY KEY,
    UserId INT FOREIGN KEY REFERENCES Users(UserId)
);

3. UNIQUE
Bir sÃ¼tundaki deÄŸerlerin tekrarlanmamasÄ±nÄ± saÄŸlar.
Bir tabloda birden fazla UNIQUE constraint olabilir.
CREATE TABLE Products (
    ProductId INT PRIMARY KEY,
    ProductName NVARCHAR(100) UNIQUE
);

4.NOT NULL
Bir sÃ¼tunun boÅŸ (NULL) deÄŸer almasÄ±nÄ± engeller.
CREATE TABLE Customers (
    CustomerId INT PRIMARY KEY,
    Name NVARCHAR(50) NOT NULL,
    Email NVARCHAR(100) NOT NULL
);

5. CHECK
Bir sÃ¼tun iÃ§in Ã¶zel bir koÅŸul tanÄ±mlar.
Ã–rneÄŸin: yaÅŸ 0â€™dan kÃ¼Ã§Ã¼k olamaz.
CREATE TABLE Employees (
    EmployeeId INT PRIMARY KEY,
    Age INT CHECK (Age >= 18)
);

6. DEFAULT
EÄŸer kullanÄ±cÄ± deÄŸer vermezse, sÃ¼tun iÃ§in varsayÄ±lan deÄŸer atar.
CREATE TABLE Orders (
    OrderId INT PRIMARY KEY,
    OrderDate DATETIME DEFAULT GETDATE()
);
Ã–zet

PRIMARY KEY â†’ SatÄ±rlarÄ± benzersiz tanÄ±mlar.
FOREIGN KEY â†’ Tablo iliÅŸkisini kurar.
UNIQUE â†’ Tekrar eden veri olmaz.
NOT NULL â†’ SÃ¼tun boÅŸ geÃ§ilemez.
CHECK â†’ Ã–zel kural uygular.
DEFAULT â†’ VarsayÄ±lan deÄŸer atar.

KÄ±saca: Constraints = VeritabanÄ±na girilen verilerin doÄŸru, tutarlÄ± ve mantÄ±klÄ± olmasÄ±nÄ± saÄŸlayan kurallar.
